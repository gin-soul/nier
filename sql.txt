AOP 面向切面编程思想:将纵向重复的代码,横向抽取(多个Servlet都需要解决乱码,通过filter过滤抽取一个方法,运用到每个Servlet)
面向切面:一把伞挡住了一个圈的纵向的雨,相当于伞切开了雨,覆盖了一个圆圈的雨的范围
七年前的那天,不过是平常的军训,却不是平常的相遇,你的笑容在我的心底埋下了一颗种子,它总让我望向那个有你的地方,越望就越收不回我的目光,它,就越快的生根发芽.
如果你还想问我大学里最大的遗憾是什么,我只想说,是我的软弱,不正面去追寻你,不敢去正视自己的弱小,虚度了四年.以至于在人生的意外中拥有了你,却无法在象牙塔外,给你一个幸福的避风港.
三年的摸爬滚打,你始终陪伴着我,没有同甘,只有共苦.遗憾在没有资格拥有你的时候却选择了占有你.过往,我只能跟你说,对不起;未来,我看不透,但是,我会穷尽我的一生,用双手去打造那个本该属于你的温暖的港湾.
敲代码去啦,停滞不前,会被一堆人超越o

JDBC java database connectivity  
sun公司为了简化和统一java连接数据库,定义的一套规范(API)

C3P0  对JDBC进行抽取工具类(初始化,配置)
DBUtils 对操作数据库进行了封装(Statement  preparedStatement)


一、对database的操作(database/databases 关键字只在对数据库的操作时见到)

1.1.创建数据库
create database 数据库名 character set 字符编码 collate 校对规则;

1.2.删除数据库
drop database 数据库名;

1.3.修改数据库，不能修改数据库名称,只是修改字符集和校对规则
alter关键字用于修改结构(数据库的结构和表结构)
alter database 数据库名 character set 字符编码;

1.4.查看所有数据库
show关键字，只用于展示数据库和表，而不会用于展示表中的数据
show databases;

1.5.查看某个数据库的结构
show create database 数据库名;

1.6.使用某个数据库
use 数据库名;

1.7.查看当前使用的数据库
select database();


二、对表结构的操作（table/tables关键字只会出现在对表结构的操作sql语句中）
2.1.创建表(对表的操作中最重要的)
create table student(
	id int primary key auto_increment,
	name varchar(10),
	score double,
	address varchar(10)
)

2.2.删除表
drop table 表名;

2.3修改表结构(难点)
除了修改表名之外，都是以alter table "表名"

2.3.1给表增加列
alter table 表名 add 字段名 类型(长度) [约束];

2.3.2修改表的字段 名称 类型 约束。
alter table 表名 change 旧字段名 新字段名 类型 约束;

2.3.3修改列的类型和约束
alter table 表名 modify 字段名 类型 约束;

2.3.4删除表的一列
alter table 表名 drop 字段名;

2.3.5修改表名
rename table 旧表名 to 新表名;

2.4查看表
2.4.1查看所有表
show tables;

2.4.2查看某个表的结构
desc 表名;

三、对表中数据的操作（重点）

3.1增加数据
insert into 表名(字段1,字段2,字段3) values(值1,值2,值3);字段和值要一一对应
insert into 表名 values(值1,值2,值3,值4);有几个字段就有几个值，如果不想给字段赋值，也要写空

3.2删除数据(一次至少删除一条数据，不能删除某条数据的某个字段)
delete from 表名 [where 条件];不写条件表示将所有数据全部删除

trancate 表名;删除表，并新建一张一样结构和名字的该表。

3.3更新数据
update 表名 set 字段1=值1,字段2=值2 [where 条件];不写条件表示将所有数据字段1的值改成值1，字段2的值改成值2

3.4查询数据
select [*] [字段1,字段2,字段3] [聚合函数] [distinct（去重关键字） 字段] 
from 表名 [where 条件]----->[group by 字段]----->[having 条件(分组后的条件)]----->[order by];

select * from 表名;

去重查询
select distinct name,age from 表名;

3.4.1别名查询
select 字段名 [as] 别名 from 表名;

3.4.2要数据一模一样才能去重

3.4.3运算查询(+-*/),对int float double有意义,只是将查询出来的结果进行运算，不改变表中的数据。

3.4.4条件查询
3.4.4.1  >、<、=、<=、>=、<>
3.4.4.2 between 值1 and 值2  ，在值1和值2之间（包含值1和值2）
3.4.4.3 in(值1,值2,值3,值4)，在值1、2、3、4之间的一个
3.4.4.4 like('张%')或者like('张_')模糊查询   %和_是占位符
3.4.4.5 is null   查询某个字段为空的
3.4.4.6 条件1 and 条件2 ,两个条件同时成立
3.4.4.7 条件1 or 条件2 ,两个条件有一个成立
3.4.4.8  not(条件) ,表示不满足该条件的数据

3.4.5 聚合函数（1.前面不能加字段名，除非是分组的字段名。2.不能用在where后面的条件中）
3.4.5.1 count(不为空的字段名或者*),计数函数,统计不同的数据个数。
3.4.5.2 sum(字段名),计算指定字段的值的和，如果字段数据类型不为数字类型的话，那么计算的和为0；
3.4.5.3 max(字段名),得到指定字段中最大的值。如果指定列是字符串类型，那么使用字符串排序运算 
3.4.5.4 min(字段名),得到指定字段中最小的值。如果指定列是字符串类型，那么使用字符串排序算法
3.4.5.5 avg();计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0

3.4.6 分组(select 后面加分组的字段名)
分组可以结合group_concat()、聚合函数使用
group by 字段名,根据某个字段分组，值相同的为一组

3.4.7 排序（写在查询语句的最后面）
order by 字段名, asc为升序(默认为升序) desc为降序

3.4.8 分组后筛选
having 条件(一般用聚合函数)

where和having的区别
1.having是分组后对数据进行过滤，where是分组前对数据进行过滤
2.having 后面可以使用聚合函数，而where 后面不能使用聚合函数



创建：create关键字，只用在创建数据库和新建表

删除:
drop 用于删除数据库、删除表、删除表的某一个字段 
delete 用于删除表中的数据，结合from 表名
truncate table 表名

更新/修改：
alter 只用于修改数据库和表结构（修改表名不需要alter关键字）

update 用于更新表中的数据


create、drop、alter这三个关键字不会出现在对数据库表中的数据的操作中。
只会出现在对数据库的结构和表的结构的操作。

select、insert、delete、update这几个关键字只会出现在对数据进行操作的sql语句中。


-- 联合两张表一起查询
SELECT * FROM star,category WHERE star.type=category.cid

SELECT * FROM star s,category c WHERE s.type=c.cid   -- 隐式内连接查询

-- 显式内连接查询  on是使用在外连接查询和显式 内连接查询中的条件
SELECT * FROM star s INNER JOIN category c ON s.type=c.cid AND s.id>20

SELECT * FROM star s JOIN category c WHERE s.type=c.cid

SELECT * FROM star

SELECT * FROM category

-- 使用左外链接查询数据
SELECT * FROM star s LEFT JOIN category c ON s.type=c.cid

-- 使用右外链接查询数据
SELECT * FROM star s RIGHT OUTER JOIN category c ON s.type=c.cid

-- 查询身价最高的明星的信息
SELECT MAX(price) FROM star  -- 将查询出来的最大价格记住  30000
SELECT * FROM star WHERE price=(SELECT MAX(price) FROM star)

-- 查询商品价格大于IPhoneX的价格的商品
-- 第一步，查询iPhoneX的价格
SELECT price FROM product WHERE pname='IphoneX'  -- 记住IPhoneX的价格为9999
-- 第二步，查询价格大于9999的商品信息
SELECT * FROM product WHERE price>9999

-- 两步合并成一步，数据代入
SELECT * FROM product WHERE price>(SELECT price FROM product WHERE pname='IphoneX')

-- 查询和农夫山泉是同一类别的商品信息
-- 第一步，查询农夫山泉的类别
SELECT TYPE FROM product WHERE pname='农夫山泉'  -- 记住农夫山泉的类别是3
-- 第二步，查询类别为3的所有商品信息
SELECT * FROM product WHERE TYPE=3

-- 两步合并成一步
SELECT * FROM product WHERE TYPE=(SELECT TYPE FROM product WHERE pname='农夫山泉')


-- 查询类别是手机数码的所有商品信息
-- 第一步，根据cname查询到手机数码这一类的cid
SELECT cid FROM category2 WHERE cname='手机数码' --- 记住cid=1    这个cid对应的就是type

-- 第二步，根据type=1，查询所有的商品信息
SELECT * FROM product WHERE TYPE=1

-- 两步合并成一步
SELECT * FROM product WHERE TYPE=(SELECT cid FROM category2 WHERE cname='手机数码')

-- 联合查询的准备工作
CREATE TABLE A(
	NAME VARCHAR(10),
	score INT
);

CREATE TABLE B(
	NAME VARCHAR(10),
	score INT
);

INSERT INTO A VALUES('a',10),('b',20),('c',30);
INSERT INTO B VALUES('a',10),('b',20),('d',40);

-- 查询a表的所有数据
SELECT * FROM a

-- 查询b表的所有数据
SELECT * FROM b

-- 使用union进行联合查询
SELECT * FROM a UNION SELECT * FROM b

-- 使用union all 进行联合查询
SELECT * FROM a UNION ALL SELECT * FROM b

-- 查询star表中的前4个明星
SELECT * FROM star LIMIT 0,4  -- 第一页的数据
SELECT * FROM star LIMIT 4,4  -- 第二页的数据
SELECT * FROM star LIMIT 8,4  -- 第三页的数据

                              -- 需要第108页的数据   客户端会传给你，需要第几页的数据curPage    每页的数据条数
                           
                           -- 将curPage转换成a
                           -- a = (curPage-1)*b
                           
-- 查询明星表前两条记录
SELECT * FROM star LIMIT 0,2
	
-- 查询明星表中第四页的数据，每页显示3条数据   ,curPage=4     a=(4-1)*3 = 9
SELECT * FROM star LIMIT 9,3

-- 查询明星表中最低价格所对应的信息
SELECT * FROM star WHERE price=(SELECT MIN(price) FROM star)

-- 先将明星按照价格从低到高排序，然后取出第一个数据
SELECT * FROM star ORDER BY price ASC LIMIT 0,1