虚拟机上 :  sqlplus scott/tiger
本机上 :  sqlplus scott/tiger@192.168.233.128:1521/orcl

isqlplus :  http://192.168.233.128:5560/isqlplus/
用户名:scott
密码:tiger



192.168.233.128:1158/em/
用户名:sys
密码:root
权限:DATABASE DBA

Oracle登录问题,可以在虚拟机cmd上输入:isnrctl status,检查服务是否开启(或者在我的电脑选择"管理",找到"服务",查看Oracle服务器运行状态(一般只有Schedule"任务调度服务"是关闭的,其他都应该是开启状态)


sqlplus sys/root as sysdba;

create user crm25 identified by crm25;

新用户设置权限:grant connect,resource,create session,create table ,unlimited tablespace,create any view,create any synonym,create database link,select any table to 用户名;


PL/SQL Developer 显示中文乱码问题


简单版本：

首先，通过 

select userenv('language') from dual;

查询oracle服务器端的编码， 如为： AMERICAN_AMERICA.US7ASCII 显示什么编码 就设置什么编码

 

在我们的客户端需要和服务器端的编码保持一致。

因此在客户端，需要设置环境变量： NLS_LANG = AMERICAN_AMERICA.US7ASCII 即可。

以上是默认编码

GBK如下：

在windows中创建一个名为“NLS_LANG”的系统环境变量，设置其值为“SIMPLIFIED CHINESE_CHINA.ZHS16GBK”，然后重新启动 pl/sql developer，这样检索出来的中文内容就不会是乱码了。

UTF-8如下：

如果想转换为UTF8字符集，可以赋予“NLS_LANG”为 “AMERICAN_AMERICA.UTF8”，然后重新启动 pl/sql developer。

其它字符集设置同上。
NLS_LANG格式：
NLS_LANG = language_territory.charset
有三个组成部分（语言、地域和字符集），每个成分控制了NLS子集的特性。其中：language 指定服务器消息的语言。territory 指定服务器的日期和数字格式。charset 指定字符集。

详细版本：

如何设置客户端字符集与服务器端字符集一致:

运行REGEDIT,第一步选HKEY_LOCAL_MACHINE,第二步选择SOFTWARE，第三步选择 Oracle，第四步选择NLS_LANG，键入与服务器端相同的字符集。

例如:AMERICAN_AMERICA.UTF8或者SIMPLIFIED CHINESE_CHINA.ZHS16GBK

oracle 10g装上后,建了个表写入中文数据,发现通过工具PL/SQL Developer中文不能正常显示.

要正常显示中文,就必须得服务器和客户端编码一致才行。于是检查：

1.检查服务器编码:

执行SQL语法:

select * from v$nls_parameters; 

也可以参照/home/oracle/.bash_profile 相关语言设置.
可以看到我的相关设置是:

LANG=zh_CN.GBK
NLS_LANG="SIMPLIFIED CHINESE_CHINA.ZHS16GBK"

2.设置本地客户端编码:

进入我的电脑,属性,高级,环境变量,添加2项:

LANG=zh_CN.GBK
NLS_LANG="SIMPLIFIED CHINESE_CHINA.ZHS16GBK"

如图:


3.重新连接sqlplus,查看数据:


显示正常.

4.PL/SQL Developer设置并重新连接:

在pl/sql developer的菜单->tools->preferences->user interface->fonts 中修改为中文字体





普通用户可以有的最高权限是dba。数据库本身的最高权限用户是sys。
给一个普通用户wen授予dba权限
首先连接到sys
sqlplus /nolog
SQL>conn  /  as sysdba
SQL>grant dba to wen;

grant create view to scott;  授权创建视图权限给scott
grant select on hr.employees to scott;
授权查询employees表的权限给scott
grant create synonym to scott;
授权创建同义词的权限给scott



select * from t1 where x in ( select y from t2 )  
-- 事实上可以理解为：  
select * from t1, ( select distinct y from t2 ) t2 where t1.x = t2.y  

 如果你有一定的SQL优化经验，从这句很自然的可以想到t2绝对不能是个大表，因为需要对t2进行全表的“唯一排序”，如果t2很大这个排序的性能是不可 忍受的。但是t1可以很大，为什么呢？最通俗的理解就是因为t1.x=t2.y可以走索引。但这并不是一个很好的解释。试想，如果t1.x和t2.y都有 索引，我们知道索引是种有序的结构，因此t1和t2之间最佳的方案是走merge join。另外，如果t2.y上有索引，对t2的排序性能也有很大提高。
 
 select * from t1 where exists ( select null from t2 where y = x )  
-- 可以理解为：  
for x in ( select * from t1 )    
  loop  
	 if ( exists ( select null from t2 where y = x.x )   
	 then   
		OUTPUT THE RECORD!  
	 end if  
end loop  

这个更容易理解，t1永远是个表扫描！因此t1绝对不能是个大表，而t2可以很大，因为y=x.x可以走t2.y的索引。
	综合以上对IN/EXISTS的讨论，我们可以得出一个基本通用的结论：IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。

例: PLSQL中的Explain plan Window:
select * from dept where deptno in (select deptno from emp where sal > 3200 );

										  cost cardinality bytes
SELECT STATEMENT, GOAL = ALL_ROWS			4		3		81
 NESTED LOOPS SEMI							4		3		81
  TABLE ACCESS FULL	SCOTT	DEPT			3		4		80
  TABLE ACCESS BY INDEX ROWID	SCOTT	EMP	1		3		21
   INDEX RANGE SCAN	SCOTT	MYINDEX			0		3	

select * from dept where exists (select deptno from emp where sal > 3200 );

SELECT STATEMENT, GOAL = ALL_ROWS			5		4		80
 FILTER					
  TABLE ACCESS FULL	SCOTT	DEPT			3		4		80
  TABLE ACCESS FULL	SCOTT	EMP				2		2		8
  
个人理解:使用的不是=符号,是>这种范围类型的符号,无法使用索引(所以exists进行了两次扫描),只能进行全表扫描,但是使用in,也要先进行一次distinct子查询(并建立索引,所以子查询结束之后有索引查询),所以总体cpu cost还是in比较大(子查询多一次,建立索引消耗资源大,这也是为什么In不适合子查询表过大的原因)


索引原理:
索引是对记录按照多个字段进行排序的一种方式。对表中的某个字段建立索引会创建另一种数据结构，其中保存着字段的值，每个值又指向与它相关的记录。这种索引的数据结构是经过排序的，因而可以对其执行二分查找。

索引的缺点是占用额外的磁盘空间。所以如果为同一个表中的很多字段都建立索引，那这个文件可能会很快膨胀到文件系统规定的上限。

当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
























-- 统计 薪资 大于 薪资最高的员工所在部门 的平均工资 和 薪资最低的员工所在部门 的平均工资 的平均工资 的员工信息。
--      sal   >      10                  100                        20           50       (100+50)/2
--  sal > (100+50)/2

-- 课堂练习一 : 查询出员工表中 薪水 大于 本部门平均薪水 的员工信息
-- 1.所有部门平均薪水
select deptno,avg(sal) avgsal from emp group by deptno;

-- 2.结果
select *
from
    emp e,
    (select deptno,avg(sal) avgsal from emp group by deptno) t
where
    e.deptno=t.deptno and e.sal > t.avgsal;
-- 注意: 子查询如果当作一张表处理,需要取别名
-- select后面,from 后面, where ,having


delete from emp where empno=9527;
-- 课堂练习二:找到员工表中工资最高的前三名
select * from emp order by sal desc nulls last;

-- select * from emp order by sal desc nulls last;
/*
   rownum : 伪列/虚列, 表示的是行号
          每查询出一条满足条件的记录,就输出一行,行号+1
          rownum 起始值是从1开始的
          
       注意事项: 先执行select,再执行order by..  rownum顺序会乱
*/
-- 查询出第5条之后的所有数据
select rownum, emp.* from emp where rownum >=5; 
select rownum, emp.* from emp where rownum <5;
select rownum, emp.* from emp where rownum >=1; 

-- 分页查询: 查询第5-10条记录
-- 1.先查询rownum<=10的所有记录
select rownum line,emp.* from emp where rownum <=10;

-- 2.结果:
select  t.* from
(select rownum line,emp.* from emp where rownum <=10) t
where t.line >=5;

-- 注意: 先执行select,再执行order by..
select rownum,emp.* from emp order by sal desc;


-- 找到员工表中工资最高的前三名
select emp.* from emp order by sal desc nulls last;

-- 1.将上面的结果当作一张表
select rownum,t.* 
from 
    (select emp.* from emp order by sal desc nulls last) t
where rownum <=3;
    

-- 课堂练习三:分组统计每年入职的员工人数
--1.查询所有的hiredate
select hiredate from emp;

-- 2. 显示所有的年
select to_char(hiredate,'yyyy') from emp;

-- 3. 分组统计
select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy');
  
-- 4. 将1987竖起来显示
select case yy when '1987' then cc end "1987"
from
(select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy')) tt;

-- 5.去除所有的空行
select sum(case yy when '1987' then cc end) "1987"
from
(select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy')) tt;

-- 6.计算Total总和
select sum(cc) Total
from
(select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy')) tt;
    
-- 7.将Total 和 1987拼接起来
select  sum(cc) Total,
        sum(case yy when '1987' then cc end) "1987"
from
(select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy')) tt;

-- 8. 最终结果
select  sum(cc) Total,
        sum(case yy when '1987' then cc end) "1987",
        sum(case yy when '1980' then cc end) "1980",
        sum(case yy when '1981' then cc end) "1981",
        sum(case yy when '1982' then cc end) "1982"
from
(select to_char(hiredate,'yyyy') yy,count(*) cc from emp group by to_char(hiredate,'yyyy')) tt;


/*
    牛和鸡的故事
    请用一条SQL语句,查询出有几头牛和几只鸡
    
    在池塘边,看到3个头,8条腿
    
    牛  鸡
    1   2
    x   y
    
    x+y=3   [0,3]
    4x+2y=8 [0,3]  
*/
-- 假设有牛表
select rownum-1 x from emp where rownum<=4;

-- 假设有鸡表
select rownum-1 y from emp where rownum<=4;

select x 牛,y 鸡 
from
    (select rownum-1 x from emp where rownum<=4) niu,
    (select rownum-1 y from emp where rownum<=4) ji
where 
    x+y=3 and 4*x+2*y=8;


-- 扩展: 华为笔试题
-- 删除表中重复记录
create table p(
    name varchar2(30)
);

insert into p values('张三');
insert into p values('李四');
insert into p values('王五');

select * from p;

/*
    rowid: 伪列,表示的每行记录存放在磁盘中真实物理地址
*/
select rowid,rownum,emp.* from emp;
select rowid,rownum,emp.* from emp where deptno in(10,20) ;
-- 删除,只保留rowid最小的那行记录
select rowid,name from p;
-- 得到所有的最小rowid
select name,min(rowid) from p group by name;

select min(rowid) from p group by name;

delete from p where rowid not in(select min(rowid) from p group by name);



select * from emp;
select * from dept;
select * from salgrade;
select * from bonus;
