面向对象设计的目标
1,可扩展性强(容易添加新功能)
2,灵活性(代码修改平稳地发生,修改一处地方带来的影响尽量少)
3,可插入性(容易将一个类抽取出去,同时将另一个有同样接口的类加进来)
4,可复用性强


设计基本原则
1,单一职责原则(一个类的功能应尽量单一)
2,开放-封闭原则(对扩展开放,对修改关闭):扩展新功能时不需要修改源代码
3,里氏代换原则(子类型必须能够替换他们的基本类型(父类型),多态,Gun需要细分为realGun<--->fakeGun,以防子类传入时,使用错误的方法)
4,依赖倒置原则(依赖抽象,不依赖具体;当一个功能可接受多种类型数据时,依赖接口进行定义数据类型标记)
5,接口隔离原则(一个接口中的抽象方法不宜过多,避免太多空实现)
6,迪米特法则(对象与对象之间应该使用尽可能少的方法来关联,低耦合:类知道其他的类的方法或者属性应该尽可能的少)(人要吃汉堡,应交给KFC类解决,而不是每个人对象去买原料,做汉堡)



单例模式
	饿汉式(多线程不需要加锁):类一加载就创建对象,占用资源
	1,私有化构造函数 2,创建并静态化类对象 3,提供静态getInstance方法(因为没有对象,所以必须依赖类名调用)
	
	懒汉式(多线程需要加锁):多线程占用资源,双重锁兼容问题
	1,私有化构造函数 2,声明静态类对象 3,提供静态getInstance方法(判断类对象是否为空,空就创建对象赋值给成员变量后,返回成员变量,不为空就直接返回对象)
	
	双重检测锁:避免每次执行getIstance方法都需要同步锁(在singleton对象存在的时候,使用锁是没有必要的,即对象存在时,并发判断完毕,继续执行后续代码不会有安全隐患)
	第一重判断,为了判断是否需要加锁,节省因为锁带来的资源浪费
	第二重判断,为了确保单例
	public class Singleton{
		private static Singleton singleton;
		private Singleton{
			super();
		}
		public static Singleton getInstance(){
			if(singleton == null){
				synchronized (Singleton.class){
					if(singleton == null){
						singleton = new Singleton();
					}
				}
			}
			return singleton;
		}
	}
	但是,由于编译器优化问题,JVM底层模型问题,双重检测锁偶尔会出问题,不建议使用

	建议使用的单例模式:(通过静态内部类实现延迟加载,类加载时不加载静态类)
	1,私有构造函数
	2,创建静态内部类(封装了创建好的静态Singleton对象)
	3,向外提供静态getInstance
	public class Singleton{
		private Singleton{
			super();
			//防止反射暴力破解
			if (SingletonInstance.singleton != null) {
				throw new RuntimeException("已经有实例了,不能调用构造函数");
			}
		}
		private static class SingletonInstance{
			public static Singleton singleton = new Singleton();
		}
		public static Singleton getInstance(){
			return SingletonInstance.singleton;
		}
		//反序列化时,直接return singleton,不生成新对象
		private Object readResolve()throws ObjectStreamException{
			return SingletonInstance.singleton;
		}
	}
	
	枚举方式实现单例(枚举是天然的单例enumeration)
	枚举能防止反序列化和反射导致单例失败(反射能提高权限,使类的protect权限无效了,再调用构造函数创建对象,即破坏了单例)
	public enum Singleton{
		INSTANCE;
		public viod anything(){
			System.out.println("枚举里面除了变量,还可以有方法");
		}
	}
	
	//反射暴力破解
	public class Main {
		public static void main(String[] args) throws Exception {
			//正常获取单例对象
			Singleton instance1 = Singleton.getInstance();
			
			//暴力获取
			Class<Singleton> clazz = (Class<Singleton>) Class.forName("com.nier.srp.Singleton");
			
			//获取空参构造方法对象
			Constructor<Singleton> constructor = clazz.getDeclaredConstructor(null);
			
			//提高权限,直接创建对象
			constructor.setAccessible(true);
			Singleton instance2 = constructor.newInstance(null);
			
			//输出为false,即破坏了单例
			System.out.println(instance1 == instance2);
		}
	}
	

	//反序列化破解单例:
	import java.io.FileInputStream;
	import java.io.FileOutputStream;
	import java.io.ObjectInputStream;
	import java.io.ObjectOutputStream;

	public class Main {
		public static void main(String[] args) throws Exception {
			Singleton instance1 = Singleton.getInstance();
			Singleton instance2 = Singleton.getInstance();
			
			//将对象序列化到文件
			/*FileOutputStream fos = new FileOutputStream("instance.txt");
			ObjectOutputStream oos = new ObjectOutputStream(fos);
			oos.writeObject(instance1);
			fos.close();
			oos.close();*/
			
			//从文件中读取对象(反序列化)
			FileInputStream fis = new FileInputStream("instance.txt");
			ObjectInputStream ois = new ObjectInputStream(fis);
			Singleton instance3 = (Singleton) ois.readObject();
			
			//instance1 == instance2 != instance3
			//在读取序列化文件instance.txt的时候,反序列化创建了新的对象,导致的单例被破坏
			//所以在Singleton类中加入阻止创建新对象的方法后,instance1 == instance2 == instance3,不需要对instance.txt进行重新写入(证明了只是在读取的时候创建了新的对象)
			System.out.println(instance1);
			System.out.println(instance2);
			System.out.println(instance3);
		}
	}

	
	
工厂模式	
	应用场景
	用来生产同一结构中的任意产品。（对于新增加的新的产品，需要修改已有代码）
	缺点
	不符合“开放封闭原则”，要新创建产品的话就要去修改工厂类。
	public class CarFactory {
			public static Car createCar(String type){
				if (type.equals("奥迪")) {
					return new Audi();
				}else if (type.equals("法拉利")) {
					return new Ferrari();
				}else {
					return null;
				}
			}
		}
		public class CarFactory2 {
			public static Car createAudi(){
				return new Audi();
			}
			public static Car createFerrari(){
				return new Ferrari();
			}
		}
	工厂方法模式
	应用场景
	用来生产同一等级结构中的固定产品。（支持增加任意产品）
	缺点
	虽然符合“开放封闭原则”，但是会增加很多个类。
	package com.nier.factory;

	public abstract class Car {
		abstract public void start();
		abstract public void run();
	}
	
	
	package com.nier.factory;

	public class Audi extends Car {

		@Override
		public void start() {
			// TODO Auto-generated method stub
			System.out.println("Audi start fast");
		}

		@Override
		public void run() {
			// TODO Auto-generated method stub
			System.out.println("Audi run fast");
		}

	}
	
	
	package com.nier.factory;

	public abstract class CarFactory {
		public abstract Car creatCar();
	}
	
	
	package com.nier.factory;

	public class AudiFactory extends CarFactory {

		@Override
		public Car creatCar() {
			// TODO Auto-generated method stub
			return new Audi();
		}

	}
	抽象工厂模式
	抽象工厂模式
	用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
	抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过你改过抽象工厂模式产生需要的对象是一种非常好的解决方式。
	例子：高端汽车工厂创建高端发动机、高端座椅、高端轮胎，低端汽车工厂创建低端的。
	package com.nier.abstractfactory;

	public abstract class Seat {
		public abstract void engine();
	}
	class HighSeat extends Seat {

		@Override
		public void engine() {
			// TODO Auto-generated method stub
			System.out.println("good");
		}
		
	}

	class LowSeat extends Seat {

		@Override
		public void engine() {
			// TODO Auto-generated method stub
			System.out.println("bad");
		}
		
	}
	
	
	package com.nier.abstractfactory;

	public abstract class Engine {
		public abstract void engine();
	}
	class HighEngine extends Engine {

		@Override
		public void engine() {
			// TODO Auto-generated method stub
			System.out.println("fast");
		}
		
	}

	class LowEngine extends Engine {

		@Override
		public void engine() {
			// TODO Auto-generated method stub
			System.out.println("slow");
		}
		
	}
	
	
	package com.nier.abstractfactory;

	public abstract class Factory {
		public abstract Engine creatEngine();
		public abstract Seat creatSeat();
	}
	
	
	package com.nier.abstractfactory;

	public class HighFactory extends Factory {

		@Override
		public Engine creatEngine() {
			// TODO Auto-generated method stub
			return new HighEngine();
		}

		@Override
		public Seat creatSeat() {
			// TODO Auto-generated method stub
			return new HighSeat();
		}

	}
	
	
	package com.nier.abstractfactory;

	public class Client {
		public static void main(String[] args) {
			HighFactory highFactory = new HighFactory();
			highFactory.creatEngine().engine();
		}
	}
	
适配器模式
	生活中的场景
	 定义
	将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能在一起工作的那些类能够一起工作。
	模式中的角色 * Client ：客户，相当于我们的笔记本电脑。(只认USB接口) * 目标结构（Target）：客户所期待的接口。目标接口可以是具体的或者抽象的类，也可以是接口。相当于USB接口 * 需要适配的类（Adaptee）：可以理解成PS2接口。 * 适配器（Adapter）：通过包装一个需要适配的对象，把原有的接口转换成目标接口。
	客户Client想直接使用Adaptee,但是使用不了，那么我们就定义一个适配器Adapter，客户只需要跟Adapter打交道就行
	
	
	类适配器
	Adapter 继承Adaptee、实现Target接口
		
	package com.nier.adapter;

	public interface USBTarget {
		public abstract void request();
	}
	
	
	package com.nier.adapter;

	public class PS2Adaptee {
		public void request() {
			// TODO Auto-generated method stub
			System.out.println("PS2接口的 键盘打字");
		}
	}
	
	
	package com.nier.adapter;
	/**
	 * 适配器,相当于PS2转USB接口
	 *
	 */
	public class Adapter extends PS2Adaptee implements USBTarget{

		@Override
		public void request() {
			// TODO Auto-generated method stub
			super.request();
		}
		
		
	}
	
	
	package com.nier.adapter;

	public class Client {
		public void test(USBTarget t) {
			t.request();
		}
	}
	
	
	package com.nier.adapter;

	public class Main {

		/**
		 * @param args
		 */
		public static void main(String[] args) {
			// TODO Auto-generated method stub
			Client client = new Client();
			client.test(new Adapter());
		}

	}
	
	
	对象适配器
	使用组合的方式，实现Target接口，将Adaptee对象通过构造函数传入Adapter类中。
	
	package com.nier.adapter;
	/**
	 * 适配器,相当于PS2转USB接口
	 * @author 15331
	 *
	 */
	public class Adapter2 implements USBTarget{
		private PS2Adaptee pS2Adaptee;
		
		public Adapter2(PS2Adaptee pS2Adaptee) {
			super();
			this.pS2Adaptee = pS2Adaptee;
		}

		@Override
		public void request() {
			// TODO Auto-generated method stub
			pS2Adaptee.request();
		}
		
		
	}
	
	public class Main {

		/**
		 * @param args
		 */
		public static void main(String[] args) {
			// TODO Auto-generated method stub
			Client client = new Client();
			client.test(new Adapter2(new PS2Adaptee()));
		}

	}	
	
	
	接口适配器
	
	事件监听机制中的Listener与Adapter的用法，
	当Listener接口有三个方法以上，而通常子类在实现时，只需要实现一个方法。另两个方法不想管，但接口规则是必须实现所有方法。所以那两个方法实现也是空方法。
	为了简化代码，API中提供了大类的这相的Adapter抽象类，实现了Listener接口，但都是空方法。 所以Adapter被标识为抽象类(这样也防止实例化一个无意义的Adapter对象)。
	这样，你的类在实现Listener时就简单了，可以直接继承Adapter,实现需要的方法就行了。
	
	
	工作中应用场景 * 经常用来做旧系统改造和升级 * 学习中见过的场景InputStreamReader(InputStream)
	
观察者模式
	实际生活中的一些场景
	广播机制。
	订阅邮件。
	消息推送
	模式中的角色
	目标对象，Subject，被观察的对象，当它的状态变化时，她需要及时通知一系列的对象。
	
	
	
Observer，观察者。
	通知观察者的方式 * 推，每次都会通知以广播方式发给所有观察者，所有观察者只能被动接受。 * 拉，观察者只要知道有情况变化即可。至于什么时候获取内容，要不要获取内容，都可以由观察者自己决定。
	自定义观察者模式
	Subject中有addObserver(Oberver o)和removeObserver(Observer o)方法添加或移除观察者，有notifyAllObservers()方法来通知所有观察者对象发生改变了。
	Observer，里面有updata方法，用于接收到改变通知后作出相应的更新。
	Java中内置的观察者
	Observable 是一个类，目标对象/被观察者继承它 当数据发生改变时，调用setChanged()表示目标状态发生改变，调用notifyObservers(Object o)来通知所有的观察者
	Observer 是一个接口，观察者实现它，能接收到目标改变的值或对象
	
	
	package com.nier.innerobserver;

	import java.util.Observable;

	public class Subject extends Observable {
		
		/**
		 * 被观察者更新了
		 * @param message
		 */
		public void updata(String message) {
			//首先得标记一下,说你发生改变了(protect方法)
			setChanged();
			notifyObservers(message);
		}
		
		//实际操作以下代码无需覆写,为了清楚了解,展示在这里
		@Override
		public synchronized void addObserver(Observer o) {
			// TODO Auto-generated method stub
			super.addObserver(o);
		}

		@Override
		public synchronized void deleteObserver(Observer o) {
			// TODO Auto-generated method stub
			super.deleteObserver(o);
		}

		@Override
		public void notifyObservers(Object arg) {
			// TODO Auto-generated method stub
			super.notifyObservers(arg);
		}
		
		//受保护方法,不能在其他类被直接调用,所以需要子类通过其他方法调用
		@Override
		protected synchronized void setChanged() {
			// TODO Auto-generated method stub
			super.setChanged();
		}
	}
		
	package com.nier.innerobserver;

	import java.util.Observable;
	import java.util.Observer;

	public class FrontObserver implements Observer {

		@Override
		public void update(Observable o, Object arg) {
			// TODO Auto-generated method stub
			System.out.println(arg + " : front 收到");
		}

	}
	
	package com.nier.innerobserver;

	import java.util.Observable;
	import java.util.Observer;

	public class BehindObserver implements Observer {

		@Override
		public void update(Observable o, Object arg) {
			// TODO Auto-generated method stub
			System.out.println(arg + " : behind 收到");
		}

	}
	
	
	package com.nier.innerobserver;

	import java.util.Observable;
	import java.util.Observer;

	public class LeftObserver implements Observer {

		@Override
		public void update(Observable o, Object arg) {
			// TODO Auto-generated method stub
			System.out.println(arg + " : left 收到");
		}

	}
	
	
	package com.nier.innerobserver;

	import java.util.Observable;
	import java.util.Observer;

	public class RightObserver implements Observer {

		@Override
		public void update(Observable o, Object arg) {
			// TODO Auto-generated method stub
			System.out.println(arg + " : right 收到");
		}

	}
	
	
	package com.nier.innerobserver;

	public class Client {
		public static void main(String[] args) {
			Subject subject = new Subject();
			subject.addObserver(new FrontObserver());
			subject.addObserver(new BehindObserver());
			subject.addObserver(new LeftObserver());
			subject.addObserver(new RightObserver());
			subject.updata("老师又来了!");
		}
	}

	
	
代理模式
	Proxy
	核心作用：
	通过代理可以控制对对象的访问，以周杰伦为例：合作商找周杰伦演出包含流程：面谈、起草合同、收预付款、订机票、唱歌、收尾款。可以找一个经纪人（代理）来处理与核心业务无关的事情、周杰伦只负责唱歌即可。而且一个经纪人可以代理很多明星。
	微商，代理一款产品，实际发货的是——大老板，发朋友圈、和人聊天、拉下线、确定购买意向、收款、求好评等等。
	代理可以详细控制访问某个对象的方法，在调用该方法钱做前置处理，调用这个方法后做后置处理。
	核心角色：
	抽象角色：定义代理角色和真实角色的公共对外方法
	真实角色：实现抽象角色，定义真实角所要实现的业务逻辑，供代理角色调用。
	代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。（将统一的流程控制代码放到代理类中处理）
	应用场景
	安全代理：屏蔽对真实角色的直接访问
	远程代理：通过代理类处理远程方法的调用。
	延迟加载： 先加载轻量级的代理对象，真正需要再加载真实对象。（如大图片问题）。
	分类
	静态代理（静态定义代理类）
	动态代理（动态生成代理类）

	JDK中自带的动态代理
	静态代理案例
	BraMarket接口：包含发货方法
	BraMarketImp类：真实角色，真正负责发货。
	ProxyStar：代理类，里面传入真实对象实现发货。
	
	
	package com.nier.proxy;

	public interface IBraMarket {
		void faHuo();
	}
	
	package com.nier.proxy;

	public class BraMarket implements IBraMarket {

		@Override
		public void faHuo() {
			// TODO Auto-generated method stub
			System.out.println("从美国发货");
		}

	}
	
	package com.nier.proxy;

	public class WeiShang implements IBraMarket {
		private IBraMarket bramarket;
		public WeiShang(IBraMarket bramarket) {
			super();
			this.bramarket = bramarket;
		};
		//完成了很多美国market没有完成的功能
		@Override
		public void faHuo() {
			// TODO Auto-generated method stub
			System.out.println("到处添加好友");
			System.out.println("发朋友圈");
			System.out.println("确定购买意向");
			bramarket.faHuo();
			System.out.println("收款");
			System.out.println("拉下线");
		}
		
	}
	
	package com.nier.proxy;

	public class Client {
		public static void main(String[] args) {
			BraMarket braMarket = new BraMarket();
			WeiShang weiShang = new WeiShang(braMarket);
			weiShang.faHuo();
		}
	}

	

	动态代理
	*相较静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样我们可以更加灵活和统一的处理众多的方法。 * java.lang.reflect.Proxy * 作用：动态生成代理类和对象，Proxy.newProxyInstance * java.lang.reflect.InvocationHandler(处理器接口) * 可以通过invoke方法实现对真实角色的访问。method.invoke * 每次通过Proxy生成代理类对象时都要指定对应的处理器对象。
	
	package com.nier.dynamicproxy;

	public interface IBraMarket {
		void faHuo();
	}
	
	
	package com.nier.dynamicproxy;

	public class BraMarket implements IBraMarket {

		@Override
		public void faHuo() {
			// TODO Auto-generated method stub
			System.out.println("从美国发货");
		}

	}

	
	package com.nier.dynamicproxy;

	import java.lang.reflect.InvocationHandler;
	import java.lang.reflect.Method;
	import java.lang.reflect.Proxy;

	public class WeiShang implements InvocationHandler {
		
		private Object object;
		//绑定一款产品,这样就能通过参数传递来实现动态代理(传递给invoke处理)
		public Object bind(Object object){
			this.object = object;
			
			//通过Proxy的newProxyInstance静态方法返回一个被代理的对象
			
			return Proxy.newProxyInstance(object.getClass().getClassLoader(), 
			object.getClass().getInterfaces(), this);
			
			/*这里的this就是实现了InvocationHandler的微商WeiShang对象,
			即:可以通过下面详解中的匿名内部类来实现,
			this即为InvocationHandler类的实现,
			所以微商类相当于下面详解的针对微商类的封装,
			只需要传进一个Object对象
			(不需要明确对象所属类型,耦合性很低,方便代理各种类型对象),
			就能对其方法所有方法进行调用*/
			
		}
		@Override
		//InvocationHandler类会自动调用invoke里面的方法
		public Object invoke(Object proxy, Method method, Object[] args)
				throws Throwable {
			
			System.out.println("到处添加好友");
			System.out.println("发朋友圈");
			System.out.println("确定购买意向");
			
			//method是被代理的厂家的方法
			method.invoke(object, args);
			
			System.out.println("收款");
			System.out.println("拉下线");
			return null;
		}
	}

	
	package com.nier.dynamicproxy;

	public class Client {
		public static void main(String[] args) {
			BraMarket braMarket = new BraMarket();
			WeiShang weiShang = new WeiShang();
			IBraMarket proxy = (IBraMarket) weiShang.bind(braMarket);
			proxy.faHuo();
		}
	}
	
详解:
package com.nier.proxy;

public interface TargetInterface {
    void method();
    void show();
}


package com.nier.proxy;

public class Target implements TargetInterface {
    @Override
    public void method() {
        System.out.println("method running...");
    }
    public void show(){
        System.out.println("show running...");
    }
}


package com.nier.proxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class ProxyTest {
    //JDK的Proxy实现的动态代理 目标对象必须有接口
    public static void main(String[] args) {
        //匿名内部类使用到的变量应定义为常量
        final Target target = new Target();

        //动态创建代理对象
        TargetInterface targetProxy = (TargetInterface) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),//与目标对象相同的类加载器
                target.getClass().getInterfaces(),//接口的字节码数组对象
                new InvocationHandler() {
                    @Override
                    //被执行几次?------>看代理对象掉用方法几次
                    //代理对象调用接口相应的方法 都是掉用invoke
                    //proxy:是代理对象(其实是和targetProxy同一个),不要在invoke内部调用,会死循环
                    //method:代表的是目标方法的字节码对象(底层实现,在targetProxy.方法时实现)
                    //args:代表的是代理对象targetProxy调用方法时传的参数
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        //System.out.println(proxy);//执行会StackOverflowError即可证明targetProxy通过指针指向了proxy
                        //targetProxy.method()调用了invoke,执行了System.out.println(proxy),在使用proxy时,就再一次调用了invoke

                        //运用反射调用方法
                        Object invoke = method.invoke(target, args);
                        //返回值就是函数的返回值
                        return invoke;//可以在这里修改返回值,即对结果进行处理Spring
                    }
                }
        );
        targetProxy.method();//调用invoke--->"method", args = null
    }
}

	
装饰者模式
	职责
	动态的为一个对象增加新的功能。
	装饰模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代理继承关系，更加灵活，同时避免类型体系的快速膨胀。
	例子：各种各样的车（飞行、潜水、人工智能）
	/*
	* BufferedReader(输入或输出流),直接继承父类,让输入,输出流均能传入
	* 这样BufferedReader()一个类就能装饰两个类
	* 如果通过分别继承输入,输出流,并在子类中进行增强,那么就会多出一个类
	* 如果需要增强的类很多,那么就会多出很多子类,让类的体系结构变得很复杂
	* 所以尽量把需要增强的相同功能抽取出来,并继承需要增强类的共同父类
	* 在构造函数中传入需要增强类的对象,在需要增强方法中,加入新功能
	* 其他方法用传入对象直接实现
	*/
	public String download(String urlStr){
			StringBuffer sb = new StringBuffer();
			String line = null;
			BufferedReader buffer = null;

			try {
				url = new URL(urlStr);
				HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();
			   //装饰者模式
				buffer = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));
				while ((line = buffer.readLine()) != null){
					sb.append(line);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			finally{
				try {
					buffer.close();
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
		return sb.toString();  
	}
	实现细节（装饰者和被装饰者实现共同的接口，将被装饰者对象传入装饰者中）

	Component：抽象构件角色

	被装饰对象和装饰对象有相同的接口。这样，客户端对象就能够以与被装饰对象相同的方式与装饰对象交互。
	ConcreteComponent:具体构件角色（被装饰对象）

	Decorator：装饰角色

	持有一个抽象构件的引用。装饰对象接收所有客户端的请求，并把这些请求转发给真实的对象（被装饰对象）。这样，就能在真实对象（被装饰对象）调用前后增加新的功能。
	ConcreteDecorator：具体装饰角色
	负责给真实对象（被装饰对象）增加新的功能。
	常见的应用场景
	IO流中的Reader r = new BufferedReader(new InputStream(new File("xxxx.txt")));
	
	
	/*
	运用wrapper类(sun公司为了方便使用者,已实现所有的方法,通过含参构造)
	wrapper类:使用装饰者模式,已经实现相同父类的所有方法
	(通过传入的子类对象来调用子类的方法,就能完成所有父类方法的实现)
	1.只需要继承该类
	2.用需要装饰的子类对象,构建构造方法
	3.并覆盖需要重写的方法即可完成装饰
	*/
	package com.nier.utils;

	import java.io.UnsupportedEncodingException;

	import javax.servlet.http.HttpServletRequest;
	import javax.servlet.http.HttpServletRequestWrapper;

	public class RequestEncodeUtils extends HttpServletRequestWrapper {

		public RequestEncodeUtils(HttpServletRequest request) {
			super(request);
			// TODO Auto-generated constructor stub
		}
		/**
		* 需要在Filter中,创建RequestEncodeUtils对象,
		* 并将Filter中的ServletRequestrequest强转后,封装到构造方法中,
		* 再通过doFilter将RequestEncodeUtils对象传递到下一层
		*/
		@Override
		public String getParameter(String name) {
			String method = super.getMethod();
			String val = "";
			if (method.equalsIgnoreCase("POST")) {
				try {
					super.setCharacterEncoding("utf-8");
				} catch (UnsupportedEncodingException e) {
					e.printStackTrace();
				}
				val = super.getParameter(name);
			}else if(method.equalsIgnoreCase("get")){
				String str = super.getParameter(name);
				try {
					byte[] bytes = str.getBytes("ISO-8859-1");
					val = new String(bytes, "UTF-8");
				} catch (UnsupportedEncodingException e) {
					e.printStackTrace();
				}
			}
			return val;
		}
		
	}

	
	
	
策略模式
	场景某个市场人员接到单后的报价策略。报价策略很复杂，可以简单做如下分类：
	普通客户小批量报价
	普通客户大批量报价
	老客户小批量报价
	老客户大批量报价
	具体采用哪个报价策略，这需要根据实际情况来确定，这时候我们就可以采用策略模式。
	可以采用条件判断来实现策略，但是不符合“开放封闭原则”，而且随着逻辑越来越复杂，代码也越来越冗余。
	定义：策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某个问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。
	组成部分：
	Context：里面包含算法实例对象和具体的实现方法，负责和具体的策略类打交道，客户端直接与Context类打交道即可。
	Strategy:算法接口
	具体的算法类。
	
	//避免通过if语句判断,致使后期修改需要涉及以前代码变动
	//不符合开放封闭原则
	package com.nier.strategy;

	public abstract class IStrategy {
		public abstract double getPrice(double price);
	}

	class NewLittleStrategy extends IStrategy{

		@Override
		public double getPrice(double price) {
			// TODO Auto-generated method stub
			return 0.98*price;
		}
		
	}

	class NewBigStrategy extends IStrategy{
		
		@Override
		public double getPrice(double price) {
			// TODO Auto-generated method stub
			return 0.90*price;
		}
		
	}

	class OldLittleStrategy extends IStrategy{
		
		@Override
		public double getPrice(double price) {
			// TODO Auto-generated method stub
			return 0.88*price;
		}
		
	}

	class OldBigStrategy extends IStrategy{
		
		@Override
		public double getPrice(double price) {
			// TODO Auto-generated method stub
			return 0.80*price;
		}
		
	}

	
	package com.nier.strategy;

	/**
	 * @author 15331
	 * 联系算法和客户端的类
	 */
	public class Context {
		private IStrategy strategy;
		
		public Context(IStrategy strategy) {
			super();
			this.strategy = strategy;
		}
		
		public double getPrice(double price) {
			return strategy.getPrice(price);
		}
	}


	package com.nier.strategy;

	public class Client {
		public static void main(String[] args) {
			Context context = new Context(new NewBigStrategy());
			System.out.println(context.getPrice(1000));
		}
	}
	
	
	
	
建造者模式
	场景
	创建一个对象时需要构建很多个小部分，然后按照一定的步骤装配起来。在使用的时候常常配合工厂模式来使用。实现了构建和装配的解耦。
	StringBuilder的append方法。
	DomBuilder。
	组成部分
	HeimaCar:tyre,engine,seat
	CarBuilder:buildTyre，buildEngine，buildSeat构建者
	Director:directCar装配者，里面要传入builder对象
	客户端只需要找装配者要产品，装配者找构建者要元件去装配	
	
	即:将建造者模式和抽象工厂模式结合(将各个部件抽象,再通过需求具体实现)
	
	
	
	
	
	
	